{"version":3,"sources":["components/WinnerOutput.js","components/MatchInput.js","App.js","serviceWorker.js","index.js"],"names":["WinnerOutput","props","className","winner","winner_conf","surfaces","value","label","MatchInput","state","p1","p2","surface","loading","display","players","handleP1Change","selectedOption","setState","console","log","handleP2Change","handleSurfaceChange","handleClick","e","preventDefault","axios","get","then","result","data","p1_win_prob","p2_win_prob","p1_name","p2_name","Math","round","max","map","ele","onChange","this","options","onClick","type","color","Component","App","href","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.118007a5.chunk.js","sourcesContent":["import React from 'react'\n\nexport default function WinnerOutput(props) {\n    return (\n        <div className = \"output\">\n            <h1>Predicted Winner: {props.winner} </h1>\n            <h2>({props.winner_conf}% Confidence)</h2>\n        </div>\n    )\n}\n","import React, { Component } from \"react\";\nimport Select from \"react-select\";\nimport axios from \"axios\";\nimport ReactLoading from \"react-loading\";\nimport WinnerOutput from \"./WinnerOutput\";\n\nconst surfaces = [\n  { value: \"Clay\", label: \"Clay\" },\n  { value: \"Hard\", label: \"Hard\" },\n  { value: \"Grass\", label: \"Grass\" }\n];\n\nexport class MatchInput extends Component {\n  state = {\n    p1: \"\",\n    p2: \"\",\n    surface: \"\",\n    loading: false,\n    display: false,\n    winner: \"\",\n    winner_conf: \"\",\n    players: [],\n  };\n\n  componentDidUpdate() {\n    axios\n    .get(\n      `https://tennis-prediction-api.herokuapp.com/players`\n    )\n    .then(result =>\n        this.setState({\n            players: result.data.map(function(ele){return {\"value\":ele, \"label\":ele,}})\n          })\n    );\n  }\n\n  handleP1Change = selectedOption => {\n    this.setState({ p1: selectedOption.value });\n    console.log(`Option selected:`, selectedOption);\n  };\n\n  handleP2Change = selectedOption => {\n    this.setState({ p2: selectedOption.value });\n    console.log(`Option selected:`, selectedOption);\n  };\n\n  handleSurfaceChange = selectedOption => {\n    this.setState({ surface: selectedOption.value });\n    console.log(`Option selected:`, selectedOption);\n  };\n\n  handleClick = e => {\n    console.log(\n      `https://tennis-prediction-api.herokuapp.com/?p1=${this.state.p1}&p2=${this.state.p2}&surface=${this.state.surface}`\n    );\n    this.setState({ display: true });\n    e.preventDefault();\n    if (this.state.p1 && this.state.p2 && this.state.surface) {\n      console.log(\"predicting match\");\n      this.setState({ loading: true }, () => {\n        axios\n          .get(\n            `https://tennis-prediction-api.herokuapp.com/?p1=${this.state.p1}&p2=${this.state.p2}&surface=${this.state.surface}`\n          )\n          .then(result =>\n            this.setState({\n              loading: false,\n              winner:\n                result.data.p1_win_prob > result.data.p2_win_prob\n                  ? result.data.p1_name\n                  : result.data.p2_name,\n              winner_conf: Math.round(\n                Math.max(result.data.p1_win_prob, result.data.p2_win_prob) *\n                  100,\n                2\n              )\n            })\n          );\n      });\n    } else {\n      console.log(\"invalid input\");\n    }\n  };\n\n  render() {\n    return (\n      <div className=\"oof\">\n        <h3>Player 1 Name:</h3>\n        <Select onChange={this.handleP1Change} options={this.state.players} />\n        <h3>Player 2 Name:</h3>\n        <Select onChange={this.handleP2Change} options={this.state.players} />\n        <h3>Surface:</h3>\n        <Select onChange={this.handleSurfaceChange} options={surfaces} />\n        <p></p>\n        <button className=\"button\" onClick={this.handleClick}>\n          Predict Match\n        </button>\n\n        {this.state.display ? (\n          this.state.loading ? (\n            <ReactLoading type={\"bars\"} color={\"black\"} className= \"output\"/>\n          ) : (\n            <WinnerOutput\n              className= \"output\"\n              winner={this.state.winner}\n              winner_conf={this.state.winner_conf}\n            />\n          )\n        ) : (\n          <h1> </h1>\n        )}\n      </div>\n    );\n  }\n}\n\nexport default MatchInput;\n","import React from 'react';\n// import './App.css';\n\nimport MatchInput from './components/MatchInput'\n\n\nfunction App() {\n  return (\n    <div className = \"background\">\n      <h1 className = \"header\">Tennis Match Predictor</h1>\n      <MatchInput/>\n      <footer className = \"footer\">\n        <p>Created by Jack Zerilli</p>\n        <a href=\"\">\n        Website Source Code</a>\n        <br>\n        </br>\n        <a href=\"https://github.com/jzerilli/tennis-api\">\n        Backend Source Code</a>\n      </footer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}